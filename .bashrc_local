#!/bin/bash

[[ -f ~/norc ]] && return

# user environment variables
export PATH="$PATH:$HOME/scripts:$HOME/.node/bin"
export NODE_PATH="$NODE_PATH:$HOME/.node/lib/node_modules"
export EDITOR="vim"

# user alias
alias tags="ctags --tag-relative=yes -R -f .git/tags ."
alias remake="make clean uninstall; make"
alias ls='ls --color=auto'
# PS1='[\u@\h \W]\$ '
alias youtube-dl="youtube-dl --exec 'notify-send {} finished'"
alias cat2="cat << EOF >>"
alias ed="$EDITOR"
alias gf="git fetch --all"
alias gd="git diff --color=always --ws-error-highlight=all"
alias gc="git commit"
alias ga="git add"
alias gall="git add --all"
alias gr="git rebase"
alias gl="git log --color=always --graph --branches --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
alias gb="git blame"
alias gg="git gui"
alias gp="git remote | xargs -L1 git push --all"
alias gcc-unsafe="gcc -fno-stack-protector -z execstack"
alias gcc-dump="gcc -fdump-tree-all -fdump-ipa-all -fdump-rtl-all"
# include-freestanding-c99 contains relevant headers
alias gcc-freestanding-c99="gcc -std=c99 -nostdinc -nostdlib -ffreestanding -I $HOME/include-freestanding-c99"
alias r2help="r2 -q -c '?*~...' -"

function nasmld32() {
    local NAME="${1%.*}"
    nasm -f elf32 -o ${NAME}.o $1
    ld -m elf_i386 -o $NAME ${NAME}.o
}

function yasmld64() {
    local NAME="${1%.*}"
    yasm -f elf64 -o ${NAME}.o $1 && \
        ld -m elf_x86_64 -o $NAME ${NAME}.o
}

function yasmld64debug() {
    local NAME="${1%.*}"
    yasm -g dwarf2 -f elf64 -o ${NAME}.o $1 && \
        ld -g -m elf_x86_64 -o $NAME ${NAME}.o
}

function yasm64() {
    local NAME="${1%.*}"
    # don't forget [BITS 64] inside
    yasm -m amd64 -o ${NAME} $1
}

function gpr() {
	git fetch gh pull/$1/head:pr$1
}

# user functions

function cd-from-ranger()
{
    ranger_pid=$(cat /tmp/ranger.pid)
    echo "get %d" > "/tmp/ranger-ipc.in.${ranger_pid}"
    cd -- "$(cat /tmp/ranger-ipc.out.${ranger_pid})"
}

function cd-to-ranger()
{
    echo "cd $PWD" > "/tmp/ranger-ipc.in.${ranger_pid}"
}

function rc() {
    if [[ "$1" != "" ]]; then
        [[ -f "${HOME}/.bashrc_${1}" ]] && . "${HOME}/.bashrc_${1}"
        [[ -f "${HOME}/.bashrc_${1}_functions" ]] && . "${HOME}/.bashrc_${1}_functions"
    else
        if [[ -n "$ZSH_VERSION" ]]; then
            source ~/.zshrc
        else
            source ~/.bashrc
        fi
    fi
}

if [[ ! -z "$PS1" ]] && [[ -n "$BASH_VERSION" ]]; then
    bind '"\e[1;5D" backward-word'
    bind '"\e[1;5C" forward-word'
    bind '"\eo":"cd-from-ranger\C-m"'
    bind '"\et":"tmux\C-m"'
    eval "$(fasd --init auto)"
fi

# ssh-agent autostart
SSH_ENV="$HOME/.ssh/environment"

function start-agent {
    echo "Initialising new SSH agent..."
    /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
    echo succeeded
    chmod 600 "${SSH_ENV}"
    . "${SSH_ENV}" > /dev/null
    /usr/bin/ssh-add;
}

# Source SSH settings, if applicable
function start-agent-if-needed() {
	if [ -f "${SSH_ENV}" ]; then
	    . "${SSH_ENV}" > /dev/null
	    #ps ${SSH_AGENT_PID} doesn't work under cywgin
	    ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
		start-agent;
	    }
	else
	    start_agent;
	fi
}

function pro() {
	if [[ "$(pwd)" =~ "problems" ]]; then
		echo "$(pwd)" > ~/current_problem.txt
	else
		cd $(cat ~/current_problem.txt)
	fi
}

#eval $(thefuck --alias)

function incr() {
	mkdir -p "${HOME}/.counters"
	local topic="${1:-default}"
	local dst_path="${HOME}/.counters/${topic}"
	if [[ -f "${dst_path}" ]]; then
		let i=$(cat "${dst_path}")+1
		echo $i > "${dst_path}"
	else
		echo 1 > "${dst_path}"
	fi
}

# load helper scripts
[[ -f ~/.bashrc_functions ]] && . ~/.bashrc_functions
[[ -f ~/.bashrc_epics ]] && . ~/.bashrc_epics

function lo() {
	local PREFIX="${PREFIXPATH-/code/prefix}"
	PREFIX="$PREFIX/$1"
	export PATH="$PREFIX/bin:$PATH"
	export LD_LIBRARY_PATH="$PREFIX/lib:$LD_LIBRARY_PATH"
}

function ve() {
    local NAME="$1"
    local PREFIX="${PREFIXPATH-/code/prefix}"
    source "${PREFIX}/ve${NAME}/bin/activate"
}

function build() {
    local CWD="$(pwd)"
    local NAME="$1"
    shift
    [[ -z "$NAME" ]] && return
    local PREFIX="${PREFIXPATH-/code/prefix}"
    local SRC="${SRCPATH-/code/src}"
    cd "$SRC"
    local SRCPROGRAM="$(find . -maxdepth 1 -type d -name "$NAME"'*' | head -n 1)"
    if [[ -z "$SRCPROGRAM" ]]; then
        unp "$NAME"*
        SRCPROGRAM="$(find . -maxdepth 1 -type d -name "$NAME"'*')"
        [[ -n "$SRCPROGRAM" ]] || cd "$CWD" && return
    fi
    cd "$SRCPROGRAM"
    local PREFIXPROGRAM="${PREFIX}/${NAME}"
    mkdir -p "$PREFIXPROGRAM"
    git pull
    # just guessing build system
    [[ -f "configure" ]] ||  ./autogen.sh || autoreconf -i || cmake \
        -DCMAKE_INSTALL_PREFIX="${PREFIXPROGRAM}" "$@" .
    ./configure --prefix="${PREFIXPROGRAM}" "$@"
    make && make install  # try even if last steps fails
    cd "$CWD"
}

function run() {
    local PROGRAM="$(command -v "$1")"
    [[ -z "$PROGRAM" ]] && lo "$1" && local PROGRAM="$(command -v "$1")"
    $PROGRAM
}

function convert-script2bash() {
    local FILENAME="$1"
    cat $FILENAME | sed -n -E '/^.*$/!d; s/^[^\$]+\$ (.+)$/\1/p' | sed '1i #!/bin/bash'
}

function script2bash() {
    local FILENAME="$1"
    script "$FILENAME"
    convert-script2bash "$FILENAME" > "$FILENAME.sh"
    chmod +x "$FILENAME.sh"
}

function activate-null-sink-a() {
    PITCH="${1:-200}"
    pactl load-module module-null-sink sink_name=sink-a
    pactl load-module module-loopback sink=sink-a
    pactl load-module module-loopback sink=sink-a
    sox -t pulseaudio default -t pulseaudio sink-a pitch -${PITCH}
    pactl unload-module module-loopback
    pactl unload-module module-null-sink
}

function pacman-remove-all() {
    sudo pacman -dd -R $(pacman -Qq | grep -ve "$(pacman -Qqg base)")
}

[[ -f "$HOME/.nix-profile/etc/profile.d/nix.sh" ]] && \
    . $HOME/.nix-profile/etc/profile.d/nix.sh

